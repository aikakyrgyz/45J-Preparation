
import java.awt.Color;
import java.util.HashMap;
import java.util.TreeMap;
import java.util.Map;
import java.util.Set;

// The 2 most important abstract data types are:
// Arrays and Lists
// Array -> random access O(1)
//          add/remove O(n)
// List ->  random access O(n)
//          add/remve O(1)


// Queues:
// Queue is efficiantly implemented as a LinkedList since add/remove from the beginning is O(1)

Queue<Integer> q = new LinkedList<Integer>();
q.add(1); // adding to the tail of the Queue
int head = q.remove(); // removes the head since it is a queue, first in first out
head = q.peek(); // just look at the head

// Stack
Stack<Integer> s = new Stack<Integer>();
s.push(1); // add at the top of the stack
int top = s.pop(); // remove the top
top = s.peek(); // look at the top of the Stack

// There are two types of sets:
// Hashset (unordered, cannot add (or go back) an element at the iterator pointer since it isn't ordered anyways
// Treeset (ordered, can add, remove a and go back)

// To use hashset, the elements must provide a hashCode method, many classes in the standard library
// implement these methods, i,e. String, Integer, Point, Rectangle, Color and all collection CLASSES

// To use treeset, the elements must provide the Comparable interface, in orded to be sorted correctly
// not many standard libraries implement this interface, though String and Integer do.



Set<String> names = new HashSet<String>();
Set<String> names = new TreeSet<String>();

names.add("Aika");
names.remove("Aika");

// Use an iterator to traverse through elements in the set
// to visit all elements in a set, use an iterator.
// or can use the simplified for loop.


Iterator<String> iter = names.iterator();
while (iter.hasNext()){
  String name = iter.next();
  ...
}


// ListIterator is different from the Iterator.
// The ListIterator has an add mehod to add an element in the iterator position, whereas
// the Iterator does not have the add method, since in the set the elements are arranged in random order, so it makes
// no sense to insert it at a specific position. It also does not have the previous method.

// However, you can remove an element in the iterator position.


// A MAP keeps associations between key and value objects
// The HashMap and Treemap classes both implement the map interface
// in the HashMap the keys are visited in the random order
// int the TreeMap the keys are visited in a sorted order

Map<String, Color> favoriteColors = new HashMap<String, Color>();
// or
Map<String, Color> favoriteColors = new TreeMap<String, Color>();

// to add an association to the map:
favoriteColors.put("Aika", Color.BlUE);

// change the value of the association just use put again
favoriteColors.put("Aika", Color.TURQUOISE);

// get the value, dict['key']

// If a key is not associated with any value, then null is returned.

Color mycolor = favoriteColors.get("Aika");

// to remove the pair, del dict['key']
favoriteColors.remove("Aika");

// Get all the keys as a SET.
// dict.keys () --> map.keySet()

Set<String> mykeySet = favoriteColors.keySet();
for (String key: mykeySet){
  Color value = favoriteColors.get(key);
  System.out.println('The favorite color of ' + key + ' is ' + value);
}

// NOTE: you can also use [] for get, put, set

// Hash Tables
// Hash function computer the hash code(integer value)

int hash_code = x.hashCode();

// collision -- two objects having the same hash codes
// a hash code is used as an array index into a hash table.
// where the hash codes collide, we will store all colliding elements in a BUCKET --> a linked list of elements with the same position value.

// In the best case, in which there are no collisions, all buckets either are empty or have a single element.
// Then adding, finding, and removign elements takes O(1).
// In order to make the table efficient, make the table about 30% larager then the number of elements you intend to insert.


// When implementing hashCode method for your own classes, combine the hash codes for the instance variables in that class.
// You hashCode method must be compatible with the equals methods, meaning,
// if two objects are equls, they must yield the same hash code, otherwise the would end up
// in different buckets and it would be duplicated.


// It is possible for two different objects to have the same hash code!!!


// If you do not provide the hashCode method, but provide the equals method, then
// the hashCode will be generated by using the hashCode method of the object class,
// which computes it based off the memory location of the object. Therefore the HashTable
// will contain objects that might have the same content.

// If you do not prove neither hashCode method nor the equals method,
// then there is no problem. Only identical objects will be considered equal.


// If you do not provide the equals method, then do not provide the hashCode method either. In this case,
// distinct objects of your class are considered different, even if they have matching contents.

// IN HASH MAP, ONLY THE KEYS ARE HASHED.


// So what can you say about the hash method?
1. It can be used to test for object inequality, but NOT object equality, for that class (since even two unequal objects can have the same code)
2. It is used by the java.util.HashSet collection class to group the elements within that set into hash buckets for swift retrieval.
